---
title: Coding Interview Expressions
index_img: /images/coding/algorithm.jpeg
banner_img: /images/coding/algorithm.jpeg
excerpt: Expressions commonly used in coding interviews
categories: Algorithms
tags:
  - Coding
  - Job Interview
date: 2025-02-16 15:35:27
updated: 2025-02-16 15:35:27
---

## Words & Phrases

* 数组: Array
* 链表: Linked List
* 哈希表/字典: Hashmap / Dictionary
* 栈: Stack
* **字典序**: Lexicographical order
* 队列: Queue
* 双端队列: Deque (Double-ended Queue)
* 二叉树: Binary Tree
* 二叉搜索树: Binary Search Tree (BST)
* 堆/优先队列: Heap / Priority Queue
* 图: Graph
* 邻接矩阵: Adjacency Matrix
* 邻接表: Adjacency List
* 并查集/不相交集合: Union-Find / Disjoint Set
* Trie 树/前缀树: Trie/Prefix Tree
* 红黑树: Red-Black Tree
* AVL 树: AVL Tree
* 滑动窗口: Sliding Window
* 双指针: Two Pointers
* **单调栈**: Monotonic Stack
* **单调队列**: Monotonic Queue
* 动态规划: Dynamic Programming (DP)
* 线段树: Segment Tree
* 树状数组: Binary Indexed Tree / Fenwick Tree
* **拓扑排序**: Topological Sort
* 辅助函数: helper function
* 线段: Line segment
* 伪节点: Dummy node
* 回溯: backtrack
* 边界条件: boundary conditions
* 连续的: consecutively
* 可除尽的: divisible
* 哨兵值: Sentinel value

## Sentences

### Ask clarifying questions

* 所以什么情况下会发生这种情况呢: So, in what situations would this happen?
* 所以什么情况下我们这种安排会失败: So, in what situations would our arrangement fail?
* 让我们用个例子去解释: Let's explain this with an example

### Think out aloud
* 可以分成两种情况讨论: It can be discussed in two cases
* 有三种情况: There are three situations
* 我们可以得出来一个规律: So we can derive a pattern
* 我们可以反过来考虑: We can think about it the other way around
* 从后向前遍历: Iterate from the back to the start / Iterate backwards
* 基于栈的方法: stack-based approach
* 逐个字符: character by character
* a 和 b 的乘积: The product of a and b
* 对于...也是一样: The same applies to ...
* 第一次出现: first occurrence
* 出现的次数: The number of occurrences
* 处理edge cases: handle edge cases
* 记录出现的次数: count occurrence / count frequency
* 减少出现的次数: decrement its count
* 获得数组中值为1的元素数量: Get the number of elements equal to 1 in the array
* 截至目前: As of now
* 基于...进行排序: sort the array based on ...
* 如果我们当前遍历的元素是1: If the current element we are iterating over is 1
* 需要找左边第一个小于这个元素的元素: Need to find the first element on the left that is smaller than this element
* 当这个循环停止的时候: when this loop stops
* 逐个字符都相同: The characters are identical one by one
* 如果我们读取到了乘法或者除法运算符，我们将立刻进行运算: If we encounter a multiplication or division operator, we will immediately perform the calculation
* 紧邻的上一个字符: The immediately preceding character
* 在数组的后半部分: In the latter half of the array
* 在数组的前半部分: In the first half of the array
* 我们可以比较这个元素和它紧邻的前面的元素: We can compare this element with the element immediately preceding it
* 我们可以把位置为 i 的元素移到 i - 1: We can move the element at position i to position i - 1
* 所以我们需要记录一下哪个字符出现过: So we need to keep track of which characters have already appeared
* 我们可以把这个链表分成两半: We can split this linked list into two halves
* 数它连续出现了几次: count how many times it repeats consecutively
* 数连续出现的字符个数: count consecutive repeating characters

### Others

* 我能思考一会吗: May I take a moment to think?
* 我的思路正确吗: 
  * Am I on the right track?
  * Is my approach correct?
* I have read and understood the problem, but I have some clarification questions and let's discuss about them.
* Let's break this down step by step
* If I go silent for a while, it means I'm thinking. When I'm ready to continue coding or share my thoughts, I'll let you know.
* Alright, I've finished writing my code. I'll review it, then share my approach. After that, I'll provide some examples for testing.

## References
- [Leetcode 口语词汇积累](https://www.xiaohongshu.com/explore/679cf52c00000000180112b4?xsec_token=ABmKxwUdqymzrY7YScNUmKiXCeB2bxHFcD9I3OiQb-39o=&xsec_source=pc_user&source=web_user_page)